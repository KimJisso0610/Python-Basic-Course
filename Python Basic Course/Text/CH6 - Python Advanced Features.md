# 人工智能社团基础课——Python编程
# CH6 - Python高级特性
## 前言
本章可当作扩展知识，不要求掌握，时间不够的同学可以直接前往CH7。

如果你在看的过程中发现：不行了，看不懂。那也可以立即结束，不看了。

## 迭代
在Python中我们用for…in…循环依次取出list(tuple/set/dict)中的元素的过程称为迭代。其中可以迭代的数据类型称为iterable(可迭代对象)。
```python 3
List = [1,2,3,4,5]
for i in List:  # 迭代过程
    print(i)
```
实际上，每一次for…in…循环只取出List中的一个元素。

## 解析语法
任何可迭代对象都可以用解析语法来创建，但是我们重点讲的是列表解析。请注意：列表解析、列表解析式、列表生成式，实际上是一个意思。

列表生成式：将一个列表转换成另一个列表的工具。在转换过程中，可以指定元素必须符合一定的条件，才能添加至新的列表中，这样每个元素都可以按需要进行转换。

1. for...in...循环的列表生成式
![avatar](/Python%20Basic%20Course/Picture/35.png)

2. for..in...循环中含有条件语句的列表生成式
![avatar](/Python%20Basic%20Course/Picture/36.png)
   1. for…in…语句在最后
   2. elif需要拆解
   3. 条件语句的操作放if前面，条件放if后面
   4. 每一个if后面必须带else
   
   转换后的结果如下：
   ![avatar](/Python%20Basic%20Course/Picture/37.png)

   特殊情况：只有一个if语句。
   ```python 3
   List = [1,2,3,4,5]
   List2 = []
   for i in List:
       if i%2 != 0:
           List2.append(i*i) 
    print(List2)
   ```
   此时若写成下面这种形式就会报错：
   ```python 3
   List2 = [i*i if i%2 != 0 for i in List]
   ```
   因为if后面必须跟上一个else。因此，只有一个if语句时，应把if语句放在for…in…语句之后：
   ```python 3
   List2 = [i*i for i in List if i%2 != 0]
   ```
3. for…in…循环嵌套的列表生成式
   
   在外层的for...in...语句放在前面。

   例如：
   ![avatar](/Python%20Basic%20Course/Picture/38.png)

## 生成器
通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。

所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器(generator)。

我们可以通过解析语法创建生成器：
1. []：列表生成式
2. {}：集合/字典生成式
3. ()：生成器
   
例如：
```python 3
List = [1,2,3,4,5]
List2 = [i*i for i in List]
Generator = (i*i for i in List)
print(List2)
print(Generator)
```
大家可以把代码copy到IDE上运行查看结果。

我们可以看到，生成器是不能直接输出的。我们输出生成器的元素，可以用如下方法：
1. 可以调用next(Generator)进行迭代，每调用一次输出一个元素，当元素取完时调用next()函数会抛出异常。
2. 用for…in…迭代。
3. 用list()函数将生成器中会产生的全部元素放入list内。（迭代器也同样适用，在迭代器部分就不说了）

同时，我们可以通过函数创建生成器，方法：把return改为yield即可。

例如斐波那契数列函数：
```python 3
def fib1(max):
    n, a, b = 0, 0, 1
    while n < max:
        print(b)
        a, b = b, a+b
        n += 1

fib1(10) #直接输出结果

def fib2(max):
    n, a, b = 0, 0, 1
    while n < max:
        yield b
        a, b = b, a+b
        n += 1
generator = fib2(10) #fib2(10)就称为生成器了
```
1. 含有yield关键字的函数叫做生成器函数。
2. 每一次对生成器进行迭代(调用一次生成器函数)，运行至yield语句后就返回(如第一次调用```next(generator)```，输出1，此时a=0，b=1， n=0)。
3. 下一次迭代，从上一次的yield语句之后开始执行函数，直至下一次遇到yield语句或函数结束(如第二次调用```next(generator)```，输出1，此时a=1，b=2，n=1)。

## 迭代器
我们分析对可迭代对象进行迭代使用的过程，发现每迭代一次（即在for...in...中每循环一次）都会返回对象中的下一条数据，一直向后读取数据直到迭代了所有数据后结束。那么，在这个过程中就应该有一个“人”去记录每次访问到了第几条数据，以便每次迭代都可以返回下一条数据。我们把这个能帮助我们进行数据迭代的“人”称为迭代器(iterator)。

可迭代对象(iterable)和迭代器(iterator)的联系：所有的迭代器都是可迭代对象，但是并不是所有的可迭代对象都是迭代器。

判断可迭代对象是否是迭代器的方法：迭代器可以被next()函数调用。所以list/tuple/set/dict是可迭代对象，但不是迭代器，而生成器generator是可迭代对象，也是迭代器。

我们可以将可迭代对象转换为迭代器，方法为使用iter()函数。请把下面这段代码copy到IDE中查看结果：
```python 3
List = [1, 2, 3, 4, 5]
Iterator = iter(List)
print(next(Iterator))
next(Iterator)
print(next(Iterator))
```

## 装饰器
装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。

下面用一个例子给大家展示装饰器的创建方法：
![avatar](/Python%20Basic%20Course/Picture/39.png)

![avatar](/Python%20Basic%20Course/Picture/40.png)

![avatar](/Python%20Basic%20Course/Picture/41.png)

## 结语
真的有人看完了吗，我敬你是条汉子！

这一章确实有一点为了学而学，这些高级知识估计后续的编程都用不到。

所以，就当做是知识扩展啦~

如果有感兴趣想要深入研究的同学，可以查阅资料，或参考廖雪峰的博客。

是不是感觉有点看不过来，完全没法消化，没关系，下一章开始就不会这样了。
